[
{
	"uri": "http://minhtien088.github.io/000037-AWSCloudFormation/",
	"title": "AWS CloudFormation",
	"tags": [],
	"description": "",
	"content": "AWS CloudFormation AWS CloudFormation AWS CloudFormation - is a service that enables users to describe and represent infrastructure resources in the cloud with just a few lines of code. The service allows you to use programming languages ​​or text files to build models and provide all the necessary resources for the application to run in any region or under any account, automatically and securely. whole. The AWS CloudFormation service is free, and you only pay for the AWS resources needed for your application.\nAWS CloudShell is a browser-based shell that you can use to manage AWS services using the AWS Command Line Interface (AWS CLI) and a range of pre-installed development tools.\nContent Introduction Preparation steps Basic CloudFormation Advanced CloudFormation Clean up resources "
},
{
	"uri": "http://minhtien088.github.io/000037-AWSCloudFormation/2-prerequiste/2.1-createiamrole/",
	"title": "Create IAM Role",
	"tags": [],
	"description": "",
	"content": "Create IAM Role Access the AWS Management Console In the IAM interface Select Roles Select Create role In the Select trusted entity interface Select Custom trust policy In the Custom trust policy section, paste this JSON into it, remember to replace \u0026lt;ACCOUNT_ID\u0026gt; with your actual AWS Account ID: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;AWS\u0026#34;: \u0026#34;arn:aws:iam::\u0026lt;ACCOUNT_ID\u0026gt;:root\u0026#34; }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34;, }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: \u0026#34;ec2.amazonaws.com\u0026#34; }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34; } ] } When creating a role for cross-account access, the administrator establishes a trust relationship between two accounts: the account that owns the resources and the account that contains the users. Based on this, the JSON snippet above represents the trusted entities as follows:\nAnother AWS account: In the first statement, we see:\n\u0026#34;Principal\u0026#34;: { \u0026#34;AWS\u0026#34;: \u0026#34;arn:aws:iam::\u0026lt;ACCOUNT_ID\u0026gt;:root\u0026#34; } This specifies that the AWS account with the ID \u0026lt;ACCOUNT_ID\u0026gt; is trusted. Specifically, it allows the root user of that account (and therefore, any user in that account granted appropriate permissions) to assume this role.\nAWS Service: In the second statement, we see:\n\u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: \u0026#34;ec2.amazonaws.com\u0026#34; } This specifies that the EC2 service of AWS is trusted. This means that EC2 instances can assume this role.\nOther important points:\nBoth statements allow the sts:AssumeRole action, which is the necessary action to assume the role. The version of this policy is 2012-10-17, which is the standard version for AWS IAM policies. In summary, this trust policy allows:\nA specific AWS account (identified by \u0026lt;ACCOUNT_ID\u0026gt;)\u0026hellip; The AWS EC2 service\u0026hellip; \u0026hellip;to assume this role. This creates a trust relationship between the account owning the role and the specified entities, allowing cross-account access and enabling EC2 instances to use this role.\nSelect Next In the Create role interface Find the policy AdministratorAccess Select the policy AdministratorAccess Select Next In the Role details interface Role name, enter CloudFormation-Role Description, enter Allows EC2 instances to call AWS services on your role behalf. In the Step 3: Add tags section Enter Key, example: Name Enter Value, example: CloudFormationWorkshop Select Create role Complete role creation "
},
{
	"uri": "http://minhtien088.github.io/000037-AWSCloudFormation/4-advancedcloudformation/4.1-customresources/4.1.1-createlambdafunction/",
	"title": "Create Lambda Function",
	"tags": [],
	"description": "",
	"content": "Create Lambda Function Access the interface AWS Management Console Find IAM Select IAM In the IAM interface Select Policies Select Create policy In the Create policy interface Select JSON Copy and paste the following code: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;logs:CreateLogGroup\u0026#34;, \u0026#34;logs:CreateLogStream\u0026#34;, \u0026#34;logs:PutLogEvents\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:logs:*:*:*\u0026#34; }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;ec2:CreateKeyPair\u0026#34;, \u0026#34;ec2:DescribeKeyPairs\u0026#34;, \u0026#34;ssm:PutParameter\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; }, { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: [ \u0026#34;ec2:DeleteKeyPair\u0026#34;, \u0026#34;ssm:DeleteParameter\u0026#34; ], \u0026#34;Resource\u0026#34;: \u0026#34;*\u0026#34; } ] } Select Next In Review and create step Policy name, enter ssh-key-gen-policy View services that are Allow In the Add tags section Enter Key, example: Name Enter Value, example: CloudFormationWorkshop Select Create policy Create the ssh-key-gen-policy policy successfully In the IAM interface Select Roles Select Create role In Select trusted entity step Trusted entity type, select AWS service User case, select Lambda Select Next In Add permissions step Find and select the ssh-key-gen-policy policy Select Next In the Role details interface Role name, enter ssh-key-gen-role Double check and in the Add tags section Enter Key, example: Name Enter Value, example: CloudFormationWorkshop Select Create role In the IAM interface Find ssh-key-gen-role View created roles In the AWS Management Console interface Find Lambda Select Lambda In the AWS Lambda interface Select Functions Select Create function In the Create function interface Select Author from scratch Function name, enter ssh-key-gen Run time, select Python 3.9 Select x86_64 In the Permissions interface Select Use an existing role Select ssh-key-gen-role In the function code editing content, enter the following code content: \u0026#34;\u0026#34;\u0026#34; This lambda implements the custom resource handler for creating an SSH key and storing in in SSM parameter store. e.g. SSHKeyCR: Type: Custom::CreateSSHKey Version: \u0026#34;1.0\u0026#34; Properties: ServiceToken: !Ref FunctionArn KeyName: MyKey An SSH key called MyKey will be created. \u0026#34;\u0026#34;\u0026#34; import os from json import dumps import sys import traceback import urllib.request import boto3 from botocore.exceptions import ClientError def log_exception(): \u0026#34;\u0026#34;\u0026#34;Log a stack trace\u0026#34;\u0026#34;\u0026#34; exc_type, exc_value, exc_traceback = sys.exc_info() print(repr(traceback.format_exception(exc_type, exc_value, exc_traceback))) def send_response(event, context, response): \u0026#34;\u0026#34;\u0026#34;Send a response to CloudFormation to handle the custom resource lifecycle\u0026#34;\u0026#34;\u0026#34; responseBody = { \u0026#39;Status\u0026#39;: response, \u0026#39;Reason\u0026#39;: \u0026#39;See details in CloudWatch Log Stream: \u0026#39; + context.log_stream_name, \u0026#39;PhysicalResourceId\u0026#39;: context.log_stream_name, \u0026#39;StackId\u0026#39;: event[\u0026#39;StackId\u0026#39;], \u0026#39;RequestId\u0026#39;: event[\u0026#39;RequestId\u0026#39;], \u0026#39;LogicalResourceId\u0026#39;: event[\u0026#39;LogicalResourceId\u0026#39;], } print(\u0026#39;RESPONSE BODY: \\n\u0026#39; + dumps(responseBody)) data = dumps(responseBody).encode(\u0026#39;utf-8\u0026#39;) req = urllib.request.Request(event[\u0026#39;ResponseURL\u0026#39;], data, headers={\u0026#39;Content-Length\u0026#39;: len(data), \u0026#39;Content-Type\u0026#39;: \u0026#39;\u0026#39;}) req.get_method = lambda: \u0026#39;PUT\u0026#39; try: with urllib.request.urlopen(req) as response: print(f\u0026#39;response.status: {response.status}, response.reason: {response.reason}\u0026#39;) print(\u0026#39;response from cfn: \u0026#39; + response.read().decode(\u0026#39;utf-8\u0026#39;)) except urllib.error.URLError: log_exception() raise Exception(\u0026#39;Received non-200 response while sending response to AWS CloudFormation\u0026#39;) return True def custom_resource_handler(event, context): \u0026#34;\u0026#34;\u0026#34; This function creates a PEM key, commits it as a key pair in EC2, and stores it, encrypted, in SSM. To retrieve the key with currect RSA format, you must use the command line: aws ssm get-parameter \\ --name \u0026lt;KEYNAME\u0026gt; \\ --with-decryption \\ --region \u0026lt;REGION\u0026gt; \\ --output text Copy the values from (and including) -----BEGIN RSA PRIVATE KEY----- to -----END RSA PRIVATE KEY----- into a file. To use it, change the permissions to 600 Ensure to bundle the necessary packages into the zip stored in S3 \u0026#34;\u0026#34;\u0026#34; print(\u0026#34;Event JSON: \\n\u0026#34; + dumps(event)) request_type = event[\u0026#39;RequestType\u0026#39;] resource_properties = event[\u0026#39;ResourceProperties\u0026#39;] response = \u0026#39;FAILED\u0026#39; if event[\u0026#39;ResourceType\u0026#39;] == \u0026#39;Custom::CreateSSHKey\u0026#39;: pem_key_name = resource_properties[\u0026#39;KeyName\u0026#39;] ec2 = boto3.client(\u0026#39;ec2\u0026#39;) ssm_client = boto3.client(\u0026#39;ssm\u0026#39;) if request_type == \u0026#39;Create\u0026#39;: try: # Check if key already exists try: ec2.describe_key_pairs(KeyNames=[pem_key_name]) print(f\u0026#34;Key pair {pem_key_name} already exists. Skipping creation.\u0026#34;) response = \u0026#39;SUCCESS\u0026#39; except ClientError as e: if e.response[\u0026#39;Error\u0026#39;][\u0026#39;Code\u0026#39;] == \u0026#39;InvalidKeyPair.NotFound\u0026#39;: # Key does not exist, create it print(\u0026#34;Creating key name %s\u0026#34; % str(pem_key_name)) key = ec2.create_key_pair(KeyName=pem_key_name) key_material = key[\u0026#39;KeyMaterial\u0026#39;] param = ssm_client.put_parameter(Name=pem_key_name, Value=key_material, Type=\u0026#39;SecureString\u0026#39;) print(param) print(f\u0026#39;The parameter {pem_key_name} has been created.\u0026#39;) response = \u0026#39;SUCCESS\u0026#39; else: raise e except Exception as e: print(f\u0026#39;There was an error {e} creating and committing key {pem_key_name} to the parameter store\u0026#39;) log_exception() response = \u0026#39;FAILED\u0026#39; send_response(event, context, response) return if request_type == \u0026#39;Update\u0026#39;: send_response(event, context, \u0026#39;SUCCESS\u0026#39;) return if request_type == \u0026#39;Delete\u0026#39;: try: print(f\u0026#34;Deleting key name {pem_key_name}\u0026#34;) ssm_client.delete_parameter(Name=pem_key_name) ec2.delete_key_pair(KeyName=pem_key_name) response = \u0026#39;SUCCESS\u0026#39; except Exception as e: print(f\u0026#34;There was an error {e} deleting the key {pem_key_name} from SSM Parameter store or EC2\u0026#34;) log_exception() response = \u0026#39;FAILED\u0026#39; send_response(event, context, response) def lambda_handler(event, context): \u0026#34;\u0026#34;\u0026#34;Lambda handler for the custom resource\u0026#34;\u0026#34;\u0026#34; try: return custom_resource_handler(event, context) except Exception: log_exception() raise Let’s analyze what this code has to do\nFirst: Handler function - every lambda function has a handler function and they are called when any event occurs. The body of the Handler function simply calls another function that contains the content of the specific handler for the event that just occurred. def lambda_handler(event, context): \u0026#34;\u0026#34;\u0026#34;Lambda handler for the custom resource\u0026#34;\u0026#34;\u0026#34; try: return custom_resource_handler(event, context) except Exception: log_exception() raise Second: custom_resource_handler function - is a function containing detailed handling content when an event occurs. Specifically, the function will perform the determination of the request type and return the response back to CloudFormation. if request_type == \u0026#39;Create\u0026#39;: try: # Check if key already exists try: ec2.describe_key_pairs(KeyNames=[pem_key_name]) print(f\u0026#34;Key pair {pem_key_name} already exists. Skipping creation.\u0026#34;) response = \u0026#39;SUCCESS\u0026#39; except ClientError as e: if e.response[\u0026#39;Error\u0026#39;][\u0026#39;Code\u0026#39;] == \u0026#39;InvalidKeyPair.NotFound\u0026#39;: # Key does not exist, create it print(\u0026#34;Creating key name %s\u0026#34; % str(pem_key_name)) key = ec2.create_key_pair(KeyName=pem_key_name) key_material = key[\u0026#39;KeyMaterial\u0026#39;] param = ssm_client.put_parameter(Name=pem_key_name, Value=key_material, Type=\u0026#39;SecureString\u0026#39;) print(param) print(f\u0026#39;The parameter {pem_key_name} has been created.\u0026#39;) response = \u0026#39;SUCCESS\u0026#39; else: raise e except Exception as e: print(f\u0026#39;There was an error {e} creating and committing key {pem_key_name} to the parameter store\u0026#39;) log_exception() response = \u0026#39;FAILED\u0026#39; send_response(event, context, response) return Third: send_response function - is a function that sends response results to CloudFormation endpoint based on HTTP PUTS method. def send_response(event, context, response): \u0026#34;\u0026#34;\u0026#34;Send a response to CloudFormation to handle the custom resource lifecycle\u0026#34;\u0026#34;\u0026#34; responseBody = { \u0026#39;Status\u0026#39;: response, \u0026#39;Reason\u0026#39;: \u0026#39;See details in CloudWatch Log Stream: \u0026#39; + context.log_stream_name, \u0026#39;PhysicalResourceId\u0026#39;: context.log_stream_name, \u0026#39;StackId\u0026#39;: event[\u0026#39;StackId\u0026#39;], \u0026#39;RequestId\u0026#39;: event[\u0026#39;RequestId\u0026#39;], \u0026#39;LogicalResourceId\u0026#39;: event[\u0026#39;LogicalResourceId\u0026#39;], } print(\u0026#39;RESPONSE BODY: \\n\u0026#39; + dumps(responseBody)) data = dumps(responseBody).encode(\u0026#39;utf-8\u0026#39;) req = urllib.request.Request(event[\u0026#39;ResponseURL\u0026#39;], data, headers={\u0026#39;Content-Length\u0026#39;: len(data), \u0026#39;Content-Type\u0026#39;: \u0026#39;\u0026#39;}) req.get_method = lambda: \u0026#39;PUT\u0026#39; try: with urllib.request.urlopen(req) as response: print(f\u0026#39;response.status: {response.status}, response.reason: {response.reason}\u0026#39;) print(\u0026#39;response from cfn: \u0026#39; + response.read().decode(\u0026#39;utf-8\u0026#39;)) except urllib.error.URLError: log_exception() raise Exception(\u0026#39;Received non-200 response while sending response to AWS CloudFormation\u0026#39;) return True Edit the code and select Deploy After saving the Function, go to Configuration tab, select General configuration section and hit Edit button We will increase the timeout of the Lambda function to avoid errors. Set the timeout to 15 minutes then hit the Save button After increase the timeout of the Function, copy the Function ARN to a certain memo. This information will be used later in the tutorial. "
},
{
	"uri": "http://minhtien088.github.io/000037-AWSCloudFormation/4-advancedcloudformation/4.1-customresources/",
	"title": "Custom Resources",
	"tags": [],
	"description": "",
	"content": "Custom Resources You can extend CloudFormation’s usability with custom resources by delegating the work to be done to a specially designed Lambda function, to interact with the CloudFormation service.\nIn the body of your code, you’ll implement constructors, update, and delete, and the function that sends feedback about the state of the activity.\nIn this first lab, you will create a custom resource that can generate an SSH key and store it in the SSM parameter store.\nContent Create Lambda Function Create Stack Connect EC2 Instance "
},
{
	"uri": "http://minhtien088.github.io/000037-AWSCloudFormation/1-introduce/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Introduction AWS CloudFormation - is a service that enables users to describe and represent infrastructure resources in the cloud with just a few lines of code. The service allows you to use programming languages ​​or text files to build models and provide all the necessary resources for the application to run in any region or under any account, automatically and securely. whole. The AWS CloudFormation service is free, and you only pay for the AWS resources needed for your application.\nAWS CloudShell is a browser-based shell that you can use to manage AWS services using the AWS Command Line Interface (AWS CLI) and a range of pre-installed development tools.\n"
},
{
	"uri": "http://minhtien088.github.io/000037-AWSCloudFormation/3-basiccloudformation/3.1-usingcloudshell/",
	"title": "Using CloudShell",
	"tags": [],
	"description": "",
	"content": "Using CloudShell Access the AWS Management Console interface Search CloudShell Select CloudShell In the AWS CloudShell interface Usually, when selecting the AWS CloudShell service, it automatically creates a CLI environment for us to execute commands. However, in some cases, CloudShell may not automatically create one. In such instances, we will click on Open environment – where is the name of the region when opening CloudShell. Copy and paste the following command into the CloudShell Terminal to install tools that support text processing on the command line. sudo yum -y install jq gettext bash-completion Install tool cfn-lint - a tool to help you check CloudFormation yaml/json templates and other information. This includes checking that the resource’s properties are correct or that the configuration information is following best practices. pip install cfn-lint Check the cfn-lint installation is successful using the following command: cfn-lint --version Install taskcat pip install taskcat We will configure the AWS CLI to use the current Region. export ACCOUNT_ID=$(aws sts get-caller-identity --output text --query Account) export AWS_REGION=\u0026lt;REGION\u0026gt; export AZS=($(aws ec2 describe-availability-zones --query \u0026#39;AvailabilityZones[].ZoneName\u0026#39; --output text --region $AWS_REGION)) Replace the field with the ID of the region where CloudShell is currently open. We will save the configuration information to bash_profile echo \u0026#34;export ACCOUNT_ID=$ACCOUNT_ID\u0026#34; | tee -a ~/.bash_profile echo \u0026#34;export AWS_REGION=$AWS_REGION\u0026#34; | tee -a ~/.bash_profile echo \u0026#34;export AZS=${AZS[@]}\u0026#34; | tee -a ~/.bash_profile aws configure set default.region $AWS_REGION aws configure get default.region We will use a command to check if CloudShell is using the correct IAM Role. aws sts get-caller-identity --query Arn | grep CloudFormation-Role -q \u0026amp;\u0026amp; echo \u0026#34;IAM role valid\u0026#34; || echo \u0026#34;IAM role NOT valid\u0026#34; "
},
{
	"uri": "http://minhtien088.github.io/000037-AWSCloudFormation/3-basiccloudformation/3.2-createcloudformationtemplate/",
	"title": "Create CloudFormation Template",
	"tags": [],
	"description": "",
	"content": "Create CloudFormation Template One of the keys to working effectively with CloudFormation is knowing how to use the resource reference table on the AWS Resource and Property Types Reference. Here you can find a list of information and definitions of resources and properties.\nA CloudFormation template usually consists of 9 parts, details of which you can see in Template anatomy. Within the workshop, we are only interested in the following 5 main components: The structure of a CloudFormation template AWSTemplateFormatVersion (optional): Indicates the version of the template. The latest version is 2010-09-09 and although it was released a long time ago, it is still used until now.\nDescription (optional) describes information related to the template.\nParameters (optional): allows you to add optional values ​​to the template each time you need to create or update the stack.\nResources (required): specify which AWS resources you want to put on the stack for deployment, such as an Amazon EC2 instance or an Amazon S3 bucket.\nOutputs (optional) defines output values ​​that you can import into other stacks (to create cross-stack references), or as stack responses, or for display on AWS CloudFormation console.\nTemplate Parameters For each parameter we must specify the name and type for the parameter. Supported parameter types include: String, Number, CommaDelimitedList, List, AWS-Specific Parameter and SSM Parameter. Below are some parameters we use in the workshop. These include\nEC2InstanceType - defines the Instance type to be used in the template.\nLatestAmiId - allows to automatically get the latest AMI ID and include it in the template.\nSubnetID - lists all available Subnet IDs available in the region.\nSourceLocation - specifies how to use regex in the AllowedPattern property to ensure that the input is appropriate, along with the MinLength and MaxLength values.\nVPCID - lists available VPCs in the region.\nCreate a .yaml file using Notepad, name it singleec2instance.yaml and paste the following content into it AWSTemplateFormatVersion: \u0026#34;2010-09-09\u0026#34; Description: \u0026#34;Deploy Single EC2 Linux Instance as part of MGT312 Workshop\u0026#34; Parameters: EC2InstanceType: AllowedValues: - t3.nano - t3.micro - t3.small - t3.medium - t3.large - t3.xlarge - t3.2xlarge - m5.large - m5.xlarge - m5.2xlarge Default: t3.small Description: Amazon EC2 instance type Type: String LatestAmiId: Type: \u0026#39;AWS::SSM::Parameter::Value\u0026lt;AWS::EC2::Image::Id\u0026gt;\u0026#39; Default: \u0026#34;/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2\u0026#34; SubnetID: Description: ID of a Subnet. Type: AWS::EC2::Subnet::Id SourceLocation: Description : The CIDR IP address range that can be used to RDP to the EC2 instances Type: String MinLength: 9 MaxLength: 18 Default: 0.0.0.0/0 AllowedPattern: \u0026#34;(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})/(\\\\d{1,2})\u0026#34; ConstraintDescription: must be a valid IP CIDR range of the form x.x.x.x/x. VPCID: Description: ID of the target VPC (e.g., vpc-0343606e). Type: AWS::EC2::VPC::Id Resource: Security Group\nAnd we have finished setting the parameters so that we can reuse CloudFormaton in the next time. Now we will go to define the required components, which are Resources.\nIt should be noted that proficient use of the AWS Resource and Property Types Reference documentation plays a very important role in creating a CloudFormation template.\nThe first resource we add is a Security Group with a rule that allows traffic on port 80. Here we use the Intrinsic Function Ref (Intrinsic Function Ref) technique to return the value of VPCID parameter.\nAWS CloudFormation provides some built-in functionality that helps you manage Stacks and uses built-in functions in templates to assign values ​​to properties that are only available at runtime.\nCopy the following content and paste it after the existing code in the singleec2instance.yaml file from the previous step:\nResources: EC2InstanceSG: Type: AWS::EC2::SecurityGroup Properties: GroupDescription: EC2 Instance Security Group VpcId: !Ref \u0026#39;VPCID\u0026#39; SecurityGroupIngress: - IpProtocol: tcp FromPort: 80 ToPort: 80 CidrIp: !Ref SourceLocation Resource: Instance Role\nIn this step we will create a Role that we can assign to EC2 Instance, allowing it to send monitoring information and communicate with AWS Systems Manager Service (SSM). With that, an InstanceProfile is also created and references the Instance Role.\nThe code also uses the Intrinsic Function Sub technique to replace values ​​in a string with Pseudo parameters like AWS::Region and AWS::Partition.\nDummy parameters are predefined parameters. We will not declare them in the template and use them like a normal parameter.\nCopy the following content and paste it after the existing code in the singleec2instance.yaml file from the previous step:\nSSMInstanceRole: Type : AWS::IAM::Role Properties: Policies: - PolicyDocument: Version: \u0026#39;2012-10-17\u0026#39; Statement: - Action: - s3:GetObject Resource: - !Sub \u0026#39;arn:aws:s3:::aws-ssm-${AWS::Region}/*\u0026#39; - !Sub \u0026#39;arn:aws:s3:::aws-windows-downloads-${AWS::Region}/*\u0026#39; - !Sub \u0026#39;arn:aws:s3:::amazon-ssm-${AWS::Region}/*\u0026#39; - !Sub \u0026#39;arn:aws:s3:::amazon-ssm-packages-${AWS::Region}/*\u0026#39; - !Sub \u0026#39;arn:aws:s3:::${AWS::Region}-birdwatcher-prod/*\u0026#39; - !Sub \u0026#39;arn:aws:s3:::patch-baseline-snapshot-${AWS::Region}/*\u0026#39; Effect: Allow PolicyName: ssm-custom-s3-policy Path: / ManagedPolicyArns: - !Sub \u0026#39;arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore\u0026#39; - !Sub \u0026#39;arn:${AWS::Partition}:iam::aws:policy/CloudWatchAgentServerPolicy\u0026#39; AssumeRolePolicyDocument: Version: \u0026#34;2012-10-17\u0026#34; Statement: - Effect: \u0026#34;Allow\u0026#34; Principal: Service: - \u0026#34;ec2.amazonaws.com\u0026#34; - \u0026#34;ssm.amazonaws.com\u0026#34; Action: \u0026#34;sts:AssumeRole\u0026#34; SSMInstanceProfile: Type: \u0026#34;AWS::IAM::InstanceProfile\u0026#34; Properties: Roles: - !Ref SSMInstanceRole Resource: EC2 Instance\nContinue building the template with the EC2 Instance definition.\nIn this step all components including previously configured resources and parameters will be gathered together. We use the Intrinsic Function Reference !Ref technique to assign or create resources and values ​​generated at runtime. Using !Ref also affects the order in which resources are generated by CloudFormation.\nCopy the following content and paste it after the existing code in the singleec2instance.yaml file from the previous step:\nEC2Instance: Type: \u0026#34;AWS::EC2::Instance\u0026#34; Properties: ImageId: !Ref LatestAmiId InstanceType: !Ref EC2InstanceType IamInstanceProfile: !Ref SSMIstanceProfile NetworkInterfaces: - DeleteOnTermination: true DeviceIndex: \u0026#39;0\u0026#39; SubnetId: !Ref \u0026#39;Subnet\u0026#39; GroupSet: - !Ref EC2InstanceSG Tags: - Key: \u0026#34;Name\u0026#34; Value: \u0026#34;MGMT312-EC2\u0026#34; Outputs\nFinally, the Outputs content with the return result is the Private IP address of the Instance - a property value of the Resource - through the use of the GettAtt Intrinsic Function.\nRefer to the AWS Resource and Property Types Reference documentation to find additional information that can be obtained with the GetAtt or !Ref function. Copy the following content and paste it after the existing code in the singleec2instance.yaml file from the previous step:\nOutputs: EC2InstancePrivateIP: Value: !GetAtt \u0026#39;EC2Instance.PrivateIp\u0026#39; Description: Private IP for EC2 Instances Check the template one last time AWSTemplateFormatVersion: \u0026#34;2010-09-09\u0026#34; Description: \u0026#34;Deploy Single EC2 Linux Instance\u0026#34; Parameters: EC2InstanceType: AllowedValues: - t3.nano - t3.micro - t3.small - t3.medium - t3.large - t3.xlarge - t3.2xlarge - m5.large - m5.xlarge - m5.2xlarge Default: t3.small Description: Amazon EC2 instance type Type: String LatestAmiId: Type: \u0026#39;AWS::SSM::Parameter::Value\u0026lt;AWS::EC2::Image::Id\u0026gt;\u0026#39; Default: \u0026#34;/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2\u0026#34; SubnetID: Description: ID of a Subnet. Type: AWS::EC2::Subnet::Id SourceLocation: Description : The CIDR IP address range that can be used to RDP to the EC2 instances Type: String MinLength: 9 MaxLength: 18 Default: 0.0.0.0/0 AllowedPattern: \u0026#34;(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})\\\\.(\\\\d{1,3})/(\\\\d{1,2})\u0026#34; ConstraintDescription: must be a valid IP CIDR range of the form x.x.x.x/x. VPCID: Description: ID of the target VPC (e.g., vpc-0343606e). Type: AWS::EC2::VPC::Id Resources: EC2InstanceSG: Type: AWS::EC2::SecurityGroup Properties: GroupDescription: EC2 Instance Security Group VpcId: !Ref \u0026#39;VPCID\u0026#39; SecurityGroupIngress: - IpProtocol: tcp FromPort: 80 ToPort: 80 CidrIp: !Ref SourceLocation SSMInstanceRole: Type : AWS::IAM::Role Properties: Policies: - PolicyDocument: Version: \u0026#39;2012-10-17\u0026#39; Statement: - Action: - s3:GetObject Resource: - !Sub \u0026#39;arn:aws:s3:::aws-ssm-${AWS::Region}/*\u0026#39; - !Sub \u0026#39;arn:aws:s3:::aws-windows-downloads-${AWS::Region}/*\u0026#39; - !Sub \u0026#39;arn:aws:s3:::amazon-ssm-${AWS::Region}/*\u0026#39; - !Sub \u0026#39;arn:aws:s3:::amazon-ssm-packages-${AWS::Region}/*\u0026#39; - !Sub \u0026#39;arn:aws:s3:::${AWS::Region}-birdwatcher-prod/*\u0026#39; - !Sub \u0026#39;arn:aws:s3:::patch-baseline-snapshot-${AWS::Region}/*\u0026#39; Effect: Allow PolicyName: ssm-custom-s3-policy Path: / ManagedPolicyArns: - !Sub \u0026#39;arn:${AWS::Partition}:iam::aws:policy/AmazonSSMManagedInstanceCore\u0026#39; - !Sub \u0026#39;arn:${AWS::Partition}:iam::aws:policy/CloudWatchAgentServerPolicy\u0026#39; AssumeRolePolicyDocument: Version: \u0026#34;2012-10-17\u0026#34; Statement: - Effect: \u0026#34;Allow\u0026#34; Principal: Service: - \u0026#34;ec2.amazonaws.com\u0026#34; - \u0026#34;ssm.amazonaws.com\u0026#34; Action: \u0026#34;sts:AssumeRole\u0026#34; SSMInstanceProfile: Type: \u0026#34;AWS::IAM::InstanceProfile\u0026#34; Properties: Roles: - !Ref SSMInstanceRole EC2Instance: Type: \u0026#34;AWS::EC2::Instance\u0026#34; Properties: ImageId: !Ref LatestAmiId InstanceType: !Ref EC2InstanceType IamInstanceProfile: !Ref SSMInstanceProfile NetworkInterfaces: - DeleteOnTermination: true DeviceIndex: \u0026#39;0\u0026#39; SubnetId: !Ref \u0026#39;Subnet\u0026#39; GroupSet: - !Ref EC2InstanceSG Tags: - Key: \u0026#34;Name\u0026#34; Value: \u0026#34;MGMT312-EC2\u0026#34; Outputs: EC2InstancePrivateIP: Value: !GetAtt \u0026#39;EC2Instance.PrivateIp\u0026#39; Description: Private IP for EC2 Instances Upload the file to CloudShell by selecting Actions \u0026gt; Upload file \u0026gt; Choose the singleec2instance.yaml file you just created. Wait for a moment and you will see a notification that the file has been uploaded successfully. To reduce the burden of error checking of apple template code, we can use some automated testing tools to validate the syntax used in the template. For this CloudFormation workshop, we use cfn-lint Run the following command: cfn-lint singleec2instance.yaml Easy to see, there was an error with the CloudFormation template, specifically line 97, we used the wrong Subnet value. The cfn-lint tool really did a great job, detecting errors in syntax and information in the template. Modify the template by changing the Subnet value to SubnetID, and then run the cfn-lint command again. The result is that the command runs successfully and there are no errors, other than a warning about python version. We can ignore them because we are simply doing a workshop. Create CloudFormation Stack To create CloudFormation Stack, Cloud9 server is required to access and use EC2 and IAM services, so it is necessary to implement additional policy for IAM Role being attached to Cloud9 server. For example, adding necessary policies such as AmazonEC2FullAccess, IAMFullAccess Access the page AWS Management Console Find IAM Select IAM In the IAM interface Select Roles Search CloudFormation-Role Select Role name CloudFormation-Role In the CloudFormation-Role interface Select Add permissions Select Attach policies In Attach policy to CloudFormation-Role step Find AmazonEC2FullAccess Select AmazonEC2FullAccess Select Attach policies Successful Attach policies interface Continue implementing Attach policies Select Add permissions Select Attach policies In Attach policy to CloudFormation-Role step Find IAMFullAccess Select IAMFullAccess Select Attach policies Interface after Attach policies is successful To prepare to create CloudFormation Template we need to prepare VPC and Public subnet Access to AWS Management Console Find VPC Select VPC In the VPC interface Select Your VPC Select the VPC you want to use Copy VPC ID to use to create CloudFormation Template The same subnet also repeats In the VPC interface Select Subnets Select the subnet you want to use (Public Subnet) Copy Subnet ID After the Cloud9 server has enough permission to create Resources with CloudFormation, on the terminal window, run the command: You replace VPC ID and Subnet ID in the command. ParameterValue of ParameterKey=SubnetID replace with Subnet ID of step 17 ParameterValue of ParameterKey=VPCID replaced with VPCID of step 16 aws cloudformation create-stack --stack-name asg-cloudformation-stack --template-body file://singleec2instance.yaml --parameters ParameterKey=SubnetID,ParameterValue=\u0026lt;SubnetID\u0026gt; ParameterKey=VPCID,ParameterValue=\u0026lt;VPCID\u0026gt; --capabilities CAPABILITY_IAM --region us-east-1 Conduct initialization test CloudFormation Template Go to AWS Management Console Find CloudFormation Select CloudFormation In the CloudFormation interface Select Stack details Select Stack named asg-cloudformation-stack Select Events View initialization events When Status changes to CREATE_COMPLETE, the initialization is successful In the CloudFormation interface Select Stack details Select the stack just created Select Resource View information about Resource successfully initialized In the CloudFormation interface Select Stack details Select the stack just created Select Parameters View information of Key-Value initializers In the CloudFormation interface Select Stack details Select the stack just created Select Outputs Result received 1 EC2Instance To verify EC2 Instance is initialized Access the page AWS Management Console Find EC2 Select EC2 In the EC2 interface Select Instances Select the instance to be initialized Select Details to see detailed information "
},
{
	"uri": "http://minhtien088.github.io/000037-AWSCloudFormation/2-prerequiste/2.2-createiamuser/",
	"title": "Create IAM User",
	"tags": [],
	"description": "",
	"content": "Create IAM User Open interface AWS Management Console Find IAM Select IAM In the IAM interface Select Users Select Add users In the Add user section User name, enter CloudFormation-user Select Access key - Programmatic access Select Password - AWS Management Console access Select Custom password Enter password Select Show password Uncheck Require password reset Select Next:Permissions In the Set permissions interface Select Attach existing policies directly Find and select AdministratorAccess Select Next:Tags In the Tags section Enter Key, example: Name Enter Value, example: CloudFormationWorkshop Select Create user Create user successfully View user information the Console sign-in details section Select Download.csv file Select Return to users list So the user has been created successfully "
},
{
	"uri": "http://minhtien088.github.io/000037-AWSCloudFormation/4-advancedcloudformation/4.1-customresources/4.1.2-createstack/",
	"title": "Create Stack",
	"tags": [],
	"description": "",
	"content": "Create Stack Go to AWS Management Console Find CloudFormaton Select CloudFormation In the CloudFormation interface Select Stack Select Create stack Select With new resources (standard) In the Create stack interface Create a file custom_resource_cfn_mr.yml Then copy and paste the content of this code into the file and save it: Parameters: SourceAccessCIDR: Type: String Description: The CIDR IP range that is permitted to access the instance. We recommend that you set this value to a trusted IP range. Default: 0.0.0.0/0 SSHKeyName: Type: String Description: The name of the key that will be created Default: MyKey01 AMIID: Type: \u0026#39;AWS::SSM::Parameter::Value\u0026lt;AWS::EC2::Image::Id\u0026gt;\u0026#39; Description: The AMI ID that will be used to create EC2 instance Default: \u0026#34;/aws/service/ami-amazon-linux-latest/amzn2-ami-hvm-x86_64-gp2\u0026#34; VPCPublicSubnet: Type: AWS::EC2::Subnet::Id Description: Choose a public subnet in the selected VPC VPC: Type: AWS::EC2::VPC::Id Description: The VPC in which to launch the EC2 instance. We recommend you choose your default VPC. FunctionArn: Type: String Description: The ARN of the lambda function that implements the custom resource Resources: SSHKeyCR: Type: Custom::CreateSSHKey Properties: ServiceToken: !Ref FunctionArn KeyName: !Ref SSHKeyName MyEC2Instance: Type: AWS::EC2::Instance Properties: KeyName: !Ref SSHKeyName InstanceType: t2.micro ImageId: !Ref AMIID IamInstanceProfile: !Ref EC2InstanceProfile SecurityGroupIds: - !Ref EC2InstanceSG SubnetId: !Ref VPCPublicSubnet Tags: - Key: Name Value: Cfn-Workshop-Reinvent-2018-Lab1 DependsOn: SSHKeyCR EC2InstanceProfile: Type: AWS::IAM::InstanceProfile Properties: Roles: - Ref: EC2InstanceRole Path: \u0026#34;/\u0026#34; DependsOn: EC2InstanceRole EC2InstanceRole: Type: AWS::IAM::Role Properties: Policies: - PolicyDocument: Version: \u0026#39;2012-10-17\u0026#39; Statement: - Action: - s3:GetObject Resource: \u0026#34;*\u0026#34; Effect: Allow PolicyName: s3-policy - PolicyDocument: Version: \u0026#39;2012-10-17\u0026#39; Statement: - Action: - logs:CreateLogStream - logs:GetLogEvents - logs:PutLogEvents - logs:DescribeLogGroups - logs:DescribeLogStreams - logs:PutRetentionPolicy - logs:PutMetricFilter - logs:CreateLogGroup Resource: - arn:aws:logs:*:*:* - arn:aws:s3:::* Effect: Allow PolicyName: cloudwatch-logs-policy - PolicyDocument: Version: \u0026#39;2012-10-17\u0026#39; Statement: - Action: - ec2:AssociateAddress - ec2:DescribeAddresses Resource: \u0026#34;*\u0026#34; Effect: Allow PolicyName: eip-policy Path: \u0026#34;/\u0026#34; AssumeRolePolicyDocument: Version: \u0026#39;2012-10-17\u0026#39; Statement: - Action: - sts:AssumeRole Principal: Service: - ec2.amazonaws.com Effect: Allow EC2InstanceSG: Type: AWS::EC2::SecurityGroup Properties: GroupDescription: This should allow you to SSH to the instance from your location VpcId: !Ref VPC Tags: - Key: Name Value: !Sub ${AWS::StackName} SecurityGroupIngress: - Description: This should allow you to SSH from your location into an EC2 instance CidrIp: !Ref SourceAccessCIDR FromPort: 22 IpProtocol: tcp ToPort: 22 Outputs: MyEC2InstanceDNSName: Description: The DNSName of the new EC2 instance Value: !GetAtt MyEC2Instance.PublicDnsName MyEC2InstancePublicIP: Description: The Public IP address of the newly created EC2 instance Value: !GetAtt MyEC2Instance.PublicIp Select Template is ready Select Upload a template file Select Choose file Select custom_resource_cfn_mr.yml Select Next In the Stack name section, enter ssh-key-gen-cr In the Create satck interface AMI ID, let it default FunctionArn, enter the ARN of the created Lambda function SSHKeyName, enter the key pair name to create SourceAccessCIDR, enter 0.0.0.0/0 Select VPC Select Public Subnet In the Add tags section Enter Key, example: Name Enter Value, example: CloudFormationWorkshop Select Next In the Create stack interface Select I acknowledge that AWS CloudFormation might create IAM resources Select Create stack In the CloudFormation interface Select Stack Select ssh-key-gen-cr stack Select Event to view initialization events. Initialization to CREATE_COMPLETE is successful In the CloudFormation interface Select Resources View initialized resources In the CloudFormation interface Select Parameters View information Key-Value In the CloudFormation interface Select Outputs View instance has been initialized In the AWS Management Console Find EC2 Select EC2 In the EC2 interface Select Instances Select the newly created instance Select Details Select public IPv4 address View IAM Role "
},
{
	"uri": "http://minhtien088.github.io/000037-AWSCloudFormation/4-advancedcloudformation/4.2-mappingandstackset/",
	"title": "Mappings and Stacksets",
	"tags": [],
	"description": "",
	"content": "Mapping The mapping part in the CloudFormation template makes sense in assigning a key to a set of corresponding values. For example, if you want to set values ​​based on region, you can create a mapping between the region acting as the key with the specified values ​​located in the region where the template is deployed. This can be especially useful when deploying AMI installation packages to the global, which is the case where the IDs of the AMIs are different from region to region.\nStackSets AWS CloudFormation StackSets extends the functionality of Stacks by allowing you to create, update, or delete Stacks located across multiple Accounts or across multiple Regions with a single operation.\nUsing an Administrator User, you can define and manage an AWS CloudFormation template, and use this template as the basis for deploying the Stack to the Accounts and Regions you desire.\nFor example, you can easily set up AWS CloudTrail or AWS Config policies across multiple Accounts with a single StackSet operation. You can also use StackSets to deploy resources to an Account but across multiple Regions.\nIn this section, we will implement a simple CloudFormation template that will create an EC2 Instance running the web server. We will use the mapping to correctly deploy the Amazon Linux 2 AMI to the selected Region, while using StackSets to configure which Region to deploy this template. For the sake of simplicity, we will use a User with absolute administrative rights to execute, but in fact you can use another account with more limited permissions to deploy StackSets.\nFor details you can visit the Prerequisites: Granting Permissions for Stack Set Operations page for more information on how to properly configure the two Roles required for deploying StackSets across multiple Accounts.\nAccess the AWS Management Console Find CloudFormation Select CloudFormation View created stacks In the CloudFormation interface Select Stack Select Create stack Select With new resource (standard) In the Create stack interface The CloudFormation template will call two YAML files written by AWS to help define the IAM roles needed for StackSet deployment.\nCreate a file mapping_stackset_iam.yaml Then copy and paste the content of this code into the file and save it: AWSTemplateFormatVersion: \u0026#39;2010-09-09\u0026#39; Description: This CloudFormation StackSet deploys two AWS provided CloudFormation templates that add Administrator and Execution Roles required to use AWSCloudFormationStackSetAdministrationRole Resources: AWSCloudFormationStackSetAdministrationRole: Type: AWS::CloudFormation::Stack Properties: TemplateURL: https://s3.amazonaws.com/cloudformation-stackset-sample-templates-us-east-1/AWSCloudFormationStackSetAdministrationRole.yml TimeoutInMinutes: \u0026#39;3\u0026#39; AWSCloudFormationStackSetExecutionRole: Type: AWS::CloudFormation::Stack Properties: TemplateURL: https://s3.amazonaws.com/cloudformation-stackset-sample-templates-us-east-1/AWSCloudFormationStackSetExecutionRole.yml TimeoutInMinutes: \u0026#39;3\u0026#39; Parameters: AdministratorAccountId : !Ref \u0026#39;AccountID\u0026#39; Parameters: AccountID: Type: String Description: Your AWS Account ID MaxLength: 12 MinLength: 12 You can refer to the Role configuration templates here: 1. AWSCloudFormationStackSetAdministrationRole\n2. AWSCloudFormationStackSetExecutionRole\nSelect Template is ready Select Upload a template file Select Choose file Select mapping_stackset_iam.yaml Select Next In the Specify stack details interface Stack name, enter mapping-stacksets-iam AccountID, enter your account id Select Next In the Create stack interface Select I acknowledge that AWS CloudFormation might create IAM resources with custom names Select I acknowledge that AWS CloudFormation might require the following capability: CAPABILITY_AUTO_EXPAND Select Create stack About a few minutes later, two CloudFormation templates were successfully created along with the Stack. In the CloudFormation interface Chọn Stackset Xem giao diện Stackset Chọn Stackset In the Choose a template interface Bước Permissions, chọn IAM role name Chọn IAM execution role name In the Prerequisite interface Create a yaml file named mapping_stackset_ec2.yml Copy the following code into the file mapping_stackset_ec2.yml AWSTemplateFormatVersion: 2010-09-09 Description: This YAML template provisions an Amazon Linux 2 AMI and installs httpd to demonstrate proper operation in various AWS regions Parameters: SourceAccessCIDR: Type: String Description: The CIDR IP range that is permitted to access the instance. We recommend that you set this value to a trusted IP range. Default: 0.0.0.0/0 Mappings: # Mapping of Amazon Linux 2 AMI IDs in every AWS Region # When deploying a StackSet, the template will automatically deploy the proper AMI in each selected region RegionMap: us-east-1: AMI: ami-04681a1dbd79675a5 us-east-2: AMI: ami-0cf31d971a3ca20d6 us-west-1: AMI: ami-0782017a917e973e7 us-west-2: AMI: ami-6cd6f714 ap-south-1: AMI: ami-00b6a8a2bd28daf19 ap-northeast-3: AMI: ami-00f7ef6bf92e8f916 ap-northeast-2: AMI: ami-012566705322e9a8e ap-southeast-1: AMI: ami-01da99628f381e50a ap-southeast-2: AMI: ami-00e17d1165b9dd3ec ap-northeast-1: AMI: ami-08847abae18baa040 ca-central-1: AMI: ami-ce1b96aa eu-central-1: AMI: ami-0f5dbc86dd9cbf7a8 eu-west-1: AMI: ami-0bdb1d6c15a40392c eu-west-2: AMI: ami-e1768386 eu-west-3: AMI: ami-06340c8c12baa6a09 sa-east-1: AMI: ami-0ad7b0031d41ed4b9 Resources: MyEC2Instance: Type: AWS::EC2::Instance Properties: InstanceType: t2.micro ImageId: !FindInMap # !FindInMap will search the above RegionMap and automatically pick the proper AMI ID based on the region where this templte is being deployed - RegionMap - !Ref \u0026#39;AWS::Region\u0026#39; - AMI SecurityGroupIds: - !Ref EC2InstanceSG UserData: \u0026#39;Fn::Base64\u0026#39;: !Sub | #!/bin/bash -ex sudo yum install httpd -y echo \u0026#39;\u0026lt;html\u0026gt;\u0026lt;h1\u0026gt;Your CloudFormation stack successfully deployed in ${AWS::Region}!\u0026lt;/h1\u0026gt;\u0026lt;/html\u0026gt;\u0026#39; \u0026gt;/var/www/html/index.html service httpd start Tags: - Key: Name Value: !Sub ${AWS::StackName} EC2InstanceSG: Type: AWS::EC2::SecurityGroup Properties: GroupDescription: This SG allows you to verify the webserver is operational by allowing HTTP (TCP 80) traffic from your location Tags: - Key: Name Value: !Sub ${AWS::StackName} SecurityGroupIngress: - Description: Permits HTTP traffic to validate that the installed webserver is operational. CidrIp: !Ref SourceAccessCIDR FromPort: 80 IpProtocol: tcp ToPort: 80 Outputs: Website: Description: Webserver URL Value: !Sub \u0026#39;http://${MyEC2Instance.PublicDnsName}\u0026#39; Save the file mapping_stackset_ec2.yml Select Template is ready Template source, select Upload a template file Select Choose file Select mapping_stackset_ec2.yml Select Next In the Specify StackSet details interface StackSet name, enter mapping-stacksets-ec2 Select Next Select Next In the Set deployment options interface Add stacks to stack set, select Deploy new stack Account, select Deploy stack in accounts Account numbers, enter your account number In the Specify region interface Select the regions you want to deploy In the Deployment options interface Select Next Select Submit StackSet initialization process will take about 5 minutes until you see the screen similar to below. Regions have been successfully deployed StackSet In the CloudFormation interface Select Region Asia Pacific-Tokyo In Region Asia Pacific-Tokyo Select CloudFormation Select Stack Access the CloudFormation console on Region Frankurt - which is one of the Regions we have selected to deploy the StackSet - and see that a new Stack has been created. This proves our StackSet has been deployed successfully. In the CloudFormation interface Select the Stack name, it will lead us to the detailed information page. Switch to the Output tab, we will see website results and links Select the link and paste it in the browser The results obtained are exactly what we expected. The StackSet implementation has been really successful. If you’ve made it this far, congratulations! "
},
{
	"uri": "http://minhtien088.github.io/000037-AWSCloudFormation/2-prerequiste/",
	"title": "Preparation steps",
	"tags": [],
	"description": "",
	"content": "Preparation steps This workshop requires us to choose the correct Region because not all regions have the same number of services, a service may run in one region but it is unlikely that it will run in another region.\nContent Create IAM Role Create IAM User Switch Role "
},
{
	"uri": "http://minhtien088.github.io/000037-AWSCloudFormation/3-basiccloudformation/",
	"title": "Basic CloudFormation",
	"tags": [],
	"description": "",
	"content": "Basic CloudFormation After completing the lab we should already feel a bit more familiar with AWS CloudFormation by creating a CloudFormation template and knowing a few more basic CloudFormation features, and how to test templates.\nAt the same time, we also learned how to launch a CloudFormation template using the AWS CLI to create a simple Stack.\nIf you feel confident with the content of part 1, move on to part 2 of the Workshop to learn more great features of CloudFormation!\nContent Using CloudShell Create CloudFormation Template "
},
{
	"uri": "http://minhtien088.github.io/000037-AWSCloudFormation/4-advancedcloudformation/4.1-customresources/4.1.3-connectec2instance/",
	"title": "Connect EC2 Instance",
	"tags": [],
	"description": "",
	"content": "Connecting EC2 Instance In the AWS Management Console Find Systems Manager Select Systems Manager In the AWS Systems Manager interface Select Parameter Store In the Parameters Store interface Select My parameters Select MyKey01 In the MyKey01 interface Select Overview See Last modified user Select Show Value Copy the value and save cloudformation.pem Use PuTTY Key Generator to load key and Save private key Use PuTTY to connect EC2 Instance When connecting enter user name:ec2-user Use ifconfig -a command to display information of all network interfaces Do ping amazon.com -c5 to test the connection "
},
{
	"uri": "http://minhtien088.github.io/000037-AWSCloudFormation/4-advancedcloudformation/4.3-driftdetection/",
	"title": "Drift Detection",
	"tags": [],
	"description": "",
	"content": "Drift Detection AWS CloudFormation allows you to detect configuration changes in your Stack resources caused by the AWS Management Console, CLI, and SDKs. Drift is the difference between the Stack’s expected resource configuration determined by CloudFormation templates and its actual resource configuration on CloudFormation. This feature helps you better manage Stacks and ensures consistency in resource configurations. For more detailed information on Drift, refer to the AWS Blog.\nIn this exercise, we will create a CloudFormation Stack and then configure its resources using the AWS Management Console.\nAccess the interface AWS Management Console Find CloudFormation Select CloudFormation In the CloudFormation interface Select Stack Select Create stack Select With new resources (standard) In the Create stack interface Create a file my_cfn_stack.yml Then copy and paste this code and save it: AWSTemplateFormatVersion: \u0026#34;2010-09-09\u0026#34; Resources: InputQueue: Type: \u0026#34;AWS::SQS::Queue\u0026#34; Properties: QueueName: \u0026#34;DriftLab-InputQueue\u0026#34; VisibilityTimeout: 30 RedrivePolicy: deadLetterTargetArn: Fn::GetAtt: - \u0026#34;DeadLetterQueue\u0026#34; - \u0026#34;Arn\u0026#34; maxReceiveCount: 5 DeadLetterQueue: Type: \u0026#34;AWS::SQS::Queue\u0026#34; Properties: QueueName: \u0026#34;DriftLab-ErrorQueue\u0026#34; Select Template is ready Select Upload a template file Select Choose file Select my_cfn_stack.yml Select Next In the Specify stack details interface Stack name, enter drift-lab-with-sqs Select Next Select Next Select Submit In the CloudFormation interface Select Stack details Select the stack just created Select Event to see the initialization events Status changed to CREATE_COMPLETE is initialization successful In the CloudFormation interface Select Stack details Select the stack just created Select Resources View newly created resources In the CloudFormation interface Select the stack just created Select Stack actions Select Detect drift In the CloudFormation interface Select the stack just created Select Stack info See Drift status switch to IN_SYNC Access the interface AWS Management Console Find Simple Queue Service Select Simple Queue Service In the Amazon SQS interface Select DriftLab-InputQueue Select Edit In the Configuration interface Visibility timeout, enter 50 Delivery delay, enter 120 Select Save Successfully edited AWS SQS interface In the CloudFormation interface Select Stack details Select drift-lab-with-sqs Select Stack info Select Stack actions Select Detect drift In the CloudFormation interface Select Stack details Select Stack info See Drift status switch to DRIFTED In the CloudFormation interface Select Stack details Select Stack info Select Stack actions Select View drift results In the Drifts interface View Drift status See Resource drift status, InputQueue change Drift status to MODIFIED "
},
{
	"uri": "http://minhtien088.github.io/000037-AWSCloudFormation/2-prerequiste/2.3-switchrole/",
	"title": "Switch Role",
	"tags": [],
	"description": "",
	"content": "Switch Role Access the AWS Management Console interface Search for IAM Select IAM In the IAM interface Select Users Choose the CloudFormation-user created in the previous step In the CloudFormation-user interface Select Permissions Choose Add permissions Select Create inline policy In the Specify permissions interface In the Policy editor section, switch to JSON mode Paste the JSON below, remember to replace \u0026lt;ACCOUNT_ID\u0026gt; with your AWS Account ID: { \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:iam::\u0026lt;ACCOUNT_ID\u0026gt;:role/CloudFormation-Role\u0026#34; } ] } Choose Next In the Policy details section Policy name, enter CloudFormation-switchrole Choose Create policy Complete adding a Policy to the CloudFormation-user Proceed to switch roles to begin the workshop In the Switch Role interface Account ID, enter your AWS Account ID IAM role name, enter CloudFormation-Role, remember to replace \u0026lt;ACCOUNT_ID\u0026gt; with your AWS Account ID Choose Switch Role Complete the role switch In the top left corner, you will see CloudFormation-Role @ \u0026lt;ACCOUNT_ID\u0026gt;, which means the role switch was successful "
},
{
	"uri": "http://minhtien088.github.io/000037-AWSCloudFormation/4-advancedcloudformation/",
	"title": "Advanced CloudFormation",
	"tags": [],
	"description": "",
	"content": "Advanced CloudFormation In this advanced content, we explore the more complex capabilities of AWS CloudFormation together, helping you further improve your skills in working with complex templates. In addition, we learn how to use AWS CloudFormation custom resources, mapping and constraints, and how to create StackSets and macros to increase efficiency in automating infrastructure and addressing requirements complex business needs.\nContent Custom Resources Mapping and StackSet Drift Detection "
},
{
	"uri": "http://minhtien088.github.io/000037-AWSCloudFormation/5-cleanup/",
	"title": "Clean up resources",
	"tags": [],
	"description": "",
	"content": "Delete CloudShell Environment Select Region containing the environment to delete In the CloudShell interface, choose Actions Select Delete Verify environment deletion by entering delete and selecting Delete Delete a stack on the AWS CloudFormation console Go to AWS CloudFormation page In the CloudFormation interface, select Stack Select Stack to delete Select Delete Verify clearing stack Wait a few minutes for the stack to change state to DELETE_COMPLETE to be deleted successfully Delete a stack set Go to AWS CloudFormation page Select StackSets Select Stackset to delete Select Actions then select Delete StackSet Verify delete stack set and select Delete StackSet Delete Lambda Functions Go to Lambda Select Functions Select funtion(s) to delete Select Actions then select Delete Verify delete funtion(s) and select Delete Delete User Go to AWS IAM Select Users Select User to delete Verify delete user and select Delete user Delete Role Go to AWS IAM Select Roles Select Roles to delete Verify delete role and select Delete "
},
{
	"uri": "http://minhtien088.github.io/000037-AWSCloudFormation/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://minhtien088.github.io/000037-AWSCloudFormation/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]